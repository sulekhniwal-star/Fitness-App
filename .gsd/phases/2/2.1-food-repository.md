---
phase: 2
plan: 1
wave: 1
depends_on: []
files_modified: []
autonomous: true

must_haves:
  truths:
    - "Searching food calls Open Food Facts API and caches results into Hive gracefully"
  artifacts:
    - "lib/data/repositories/food_repository.dart"
    - "lib/data/providers/food_provider.dart"
---

# Plan 2.1: Food Data Repository & Caching

<objective>
Build the integration to the Open Food Facts API, parsing barcodes and string queries, then storing a cache of frequent searches locally in Hive to power the zero-cost offline-first food feature.

Purpose: To avoid runtime DB queries that cost money while providing instant Indian food search.
Output: A functional `FoodRepository` hooked into Riverpod.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- lib/data/models/food_log_model.dart
- lib/core/storage/hive_service.dart
- pubspec.yaml (checking http import)
</context>

<tasks>

<task type="auto">
  <name>Open Food Facts Client API & Refined Caching</name>
  <files>lib/data/repositories/food_repository.dart, lib/data/providers/food_provider.dart</files>
  <action>
    - Build `FoodRepository` that reaches `world.openfoodfacts.org` passing `search_terms` and retrieves JSON translating it into a list of generic maps/models.
    - Setup `barcode` endpoint reading mechanism.
    - Check the Hive `foodCacheBox` (from `HiveService.foodCacheBox`) prior to networking.
    - Expose `FoodProvider` (using riverpod) that manages search state (`loading`, `data`, `error`).
    AVOID: Implementing complex pagination for MVP. Just return top 20 matches.
  </action>
  <verify>Riverpod provider seamlessly fetches and caches dummy food items from Open Food Facts without compilation errors.</verify>
  <done>Caching triggers efficiently avoiding double calls.</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] `food_provider.dart` correctly parses Open food facts payload
</verification>

<success_criteria>
- [ ] All tasks verified
- [ ] Must-haves confirmed
</success_criteria>
